diff --git a/src/TODO b/src/TODO
index 8ee63f3..59dff56 100644
--- a/src/TODO
+++ b/src/TODO
@@ -3,5 +3,4 @@ Refactoring fr.escape.game.entity.weapons.shot : éviter la duplication de Code
 
 BONUS
 
-Faire le weaponLoaded dans le Ship
 Modifier le EdgeNotifier pour render en compte les coordonées World plutôt que Graphics
\ No newline at end of file
diff --git a/src/fr/escape/game/entity/ships/ShipFactory.java b/src/fr/escape/game/entity/ships/ShipFactory.java
index d37ca74..f85280b 100644
--- a/src/fr/escape/game/entity/ships/ShipFactory.java
+++ b/src/fr/escape/game/entity/ships/ShipFactory.java
@@ -21,7 +21,7 @@ public class ShipFactory {
 		Objects.requireNonNull(world);
 		
 		BodyDef bodyDef = new BodyDef();
-		bodyDef.position.set(x,y);
+		bodyDef.position.set(x, y);
 		bodyDef.type = type;
 		
 		CircleShape shape = new CircleShape();
diff --git a/src/fr/escape/game/entity/weapons/BlackHole.java b/src/fr/escape/game/entity/weapons/BlackHole.java
index 711203a..81c8e1a 100644
--- a/src/fr/escape/game/entity/weapons/BlackHole.java
+++ b/src/fr/escape/game/entity/weapons/BlackHole.java
@@ -7,7 +7,6 @@ import org.jbox2d.dynamics.World;
 import fr.escape.app.Foundation;
 import fr.escape.app.Graphics;
 import fr.escape.game.entity.EntityContainer;
-import fr.escape.game.entity.weapons.shot.AbstractShot;
 import fr.escape.game.entity.weapons.shot.Shot;
 import fr.escape.game.entity.weapons.shot.ShotFactory;
 import fr.escape.graphics.Texture;
@@ -44,7 +43,7 @@ public final class BlackHole implements Weapon {
 		if(!isEmpty() && shot == null) {
 			
 			shot = ShotFactory.createBlackholeShot(world, x, y, ec);
-			shot.receive(AbstractShot.MESSAGE_LOAD);
+			shot.receive(Shot.MESSAGE_LOAD);
 			
 			return true;
 		}
@@ -63,6 +62,10 @@ public final class BlackHole implements Weapon {
 			Objects.requireNonNull(world).step(1.0f/60.0f, 6, 2);
 			
 			Objects.requireNonNull(ec).push(shot);
+			shot.receive(Shot.MESSAGE_FIRE);
+			
+			// TODO Apply Speed and Angle
+			shot.receive(Shot.MESSAGE_CRUISE);
 			
 			shot = null;
 			ammunition--;
diff --git a/src/fr/escape/game/entity/weapons/Weapons.java b/src/fr/escape/game/entity/weapons/Weapons.java
index e201338..f0d90bc 100644
--- a/src/fr/escape/game/entity/weapons/Weapons.java
+++ b/src/fr/escape/game/entity/weapons/Weapons.java
@@ -21,7 +21,7 @@ public class Weapons {
 		
 		List<Weapon> list = new ArrayList<>(4);
 		
-		Weapon wB = new BlackHole(4);
+		Weapon wB = new BlackHole(Integer.MAX_VALUE);
 		Weapons.validate(wB);
 		
 		Weapon wF = new FireBall(50);
diff --git a/src/fr/escape/game/entity/weapons/shot/AbstractShot.java b/src/fr/escape/game/entity/weapons/shot/AbstractShot.java
index 800902e..c8f21ff 100644
--- a/src/fr/escape/game/entity/weapons/shot/AbstractShot.java
+++ b/src/fr/escape/game/entity/weapons/shot/AbstractShot.java
@@ -14,12 +14,6 @@ import fr.escape.game.message.Receiver;
 
 public abstract class AbstractShot implements Shot {
 	
-	public final static int MESSAGE_LOAD = 0;
-	public final static int MESSAGE_FIRE = 1;
-	public final static int MESSAGE_CRUISE = 2;
-	public final static int MESSAGE_HIT = 3;
-	public final static int MESSAGE_DESTROY = 4;
-	
 	private final EdgeNotifier eNotifier;
 	private final KillNotifier kNotifier;
 	private final Body body;
@@ -38,28 +32,6 @@ public abstract class AbstractShot implements Shot {
 		this.y = 0;
 		this.angle = 0;
 	}
-
-	/**
-	 * <p>
-	 * Shot have different state depending on the situation.
-	 * 
-	 * <p>
-	 * If you need to change its state, use this method with the given protocol:
-	 * 
-	 * <ul>
-	 * <li>MESSAGE_LOADED: Shot loaded in Ship.</li>
-	 * <li>MESSAGE_FIRE: Shot just shoot from Ship.</li>
-	 * <li>MESSAGE_CRUISE: Shot in cruise state.</li>
-	 * <li>MESSAGE_HIT: Shot hit something.</li>
-	 * <li>MESSAGE_DESTROY: Shot need to be destroyed.</li>
-	 * </ul>
-	 * 
-	 * <b>By default:</b> state is 0.
-	 * 
-	 * @see Receiver#receive(int)
-	 */
-	@Override
-	public abstract void receive(int message);
 	
 	@Override
 	public void moveBy(int x, int y) {
diff --git a/src/fr/escape/game/entity/weapons/shot/BlackHoleShot.java b/src/fr/escape/game/entity/weapons/shot/BlackHoleShot.java
index cb15786..86c89e4 100644
--- a/src/fr/escape/game/entity/weapons/shot/BlackHoleShot.java
+++ b/src/fr/escape/game/entity/weapons/shot/BlackHoleShot.java
@@ -50,28 +50,28 @@ public final class BlackHoleShot extends AbstractShot {
 	@Override
 	public void receive(int message) {
 		switch(message) { 
-			case MESSAGE_LOAD: {
+			case Shot.MESSAGE_LOAD: {
 				getBody().getFixtureList().getShape().m_radius = CoordinateConverter.toMeterX(coreHelix.getHeight());
 				isVisible = true;
 				drawCoreHelix = true;
 				break;
 			}
-			case MESSAGE_FIRE: {
+			case Shot.MESSAGE_FIRE: {
 				getBody().getFixtureList().getShape().m_radius = CoordinateConverter.toMeterX(leftHelix.getHeight());
 				drawLeftAndRightHelix = true;
 				break;
 			}
-			case MESSAGE_CRUISE: {
+			case Shot.MESSAGE_CRUISE: {
 				getBody().getFixtureList().getShape().m_radius = CoordinateConverter.toMeterX(rightHelix.getHeight());
 				break;
 			}
-			case MESSAGE_HIT: {
+			case Shot.MESSAGE_HIT: {
 				getBody().getFixtureList().getShape().m_radius = CoordinateConverter.toMeterX(eventHorizon.getHeight());
 				drawEventHorizon = true;
 				timer = 0;
 				break;
 			}
-			case MESSAGE_DESTROY: {
+			case Shot.MESSAGE_DESTROY: {
 				
 				isVisible = false;
 				
@@ -97,7 +97,7 @@ public final class BlackHoleShot extends AbstractShot {
 		draw(graphics);
 		
 		if(drawEventHorizon && timer > ((EVENT_HORIZON_SPEED * 2) + EVENT_HORIZON_TIME)) {
-			receive(AbstractShot.MESSAGE_DESTROY);
+			receive(Shot.MESSAGE_DESTROY);
 		}
 		
 	}
@@ -121,6 +121,7 @@ public final class BlackHoleShot extends AbstractShot {
 	}
 
 	private void drawCoreHelix(Graphics graphics) {
+		
 		int x = CoordinateConverter.toPixelX(getBody().getPosition().x) - coreHelix.getWidth() / 2;
 		int y = CoordinateConverter.toPixelY(getBody().getPosition().y) - coreHelix.getHeight() / 2;
 		
@@ -129,14 +130,17 @@ public final class BlackHoleShot extends AbstractShot {
 	
 	private void drawLeftAndRightHelix(Graphics graphics) {
 		
-		int x = getX() - (leftHelix.getWidth() / 2);
-		int y = getY() - (leftHelix.getHeight() / 2);
+		int centerX = CoordinateConverter.toPixelX(getBody().getPosition().x);
+		int centerY = CoordinateConverter.toPixelY(getBody().getPosition().y);
+		
+		int x = centerX - (leftHelix.getWidth() / 2);
+		int y = centerY - (leftHelix.getHeight() / 2);
 		int angle = (int) (((float) timer / ROTATION_SPEED) * 360);
 		
 		graphics.draw(leftHelix, x, y, angle);
 		
-		x = getX() - (rightHelix.getWidth() / 2);
-		y = getY() - (rightHelix.getHeight() / 2);
+		x = centerX - (rightHelix.getWidth() / 2);
+		y = centerY - (rightHelix.getHeight() / 2);
 		angle = 360 - angle;
 		
 		graphics.draw(rightHelix, x, y, angle);
@@ -145,11 +149,14 @@ public final class BlackHoleShot extends AbstractShot {
 	private void drawEventHorizon(Graphics graphics) {
 
 		float size = getEventHorizonSize();
+		
+		int centerX = CoordinateConverter.toPixelX(getBody().getPosition().x);
+		int centerY = CoordinateConverter.toPixelY(getBody().getPosition().y);
 
 		int width = (int) (eventHorizon.getWidth() * size);
 		int height = (int) (eventHorizon.getHeight() * size);
-		int x = getX() - (width / 2);
-		int y = getY() - (height / 2);
+		int x = centerX - (width / 2);
+		int y = centerY - (height / 2);
 		
 		graphics.draw(eventHorizon, x, y, x + width, y + height);
 	}
diff --git a/src/fr/escape/game/entity/weapons/shot/Fireball.java b/src/fr/escape/game/entity/weapons/shot/Fireball.java
index 2cf981b..c14c637 100644
--- a/src/fr/escape/game/entity/weapons/shot/Fireball.java
+++ b/src/fr/escape/game/entity/weapons/shot/Fireball.java
@@ -59,24 +59,24 @@ public final class Fireball extends AbstractShot {
 	@Override
 	public void receive(int message) {
 		switch(message) {
-		case MESSAGE_LOAD: {
+		case Shot.MESSAGE_LOAD: {
 			isVisible = true;
 			radiusGrown = true;
 			break;
 		}
-		case MESSAGE_FIRE: {
+		case Shot.MESSAGE_FIRE: {
 			radiusGrown = false;
 			break;
 		}
-		case MESSAGE_CRUISE: {
+		case Shot.MESSAGE_CRUISE: {
 			
 			break;
 		}
-		case MESSAGE_HIT: {
+		case Shot.MESSAGE_HIT: {
 
 			break;
 		}
-		case MESSAGE_DESTROY: {
+		case Shot.MESSAGE_DESTROY: {
 			
 			isVisible = false;
 			
diff --git a/src/fr/escape/game/entity/weapons/shot/Shot.java b/src/fr/escape/game/entity/weapons/shot/Shot.java
index d4a5bc4..fd24f66 100644
--- a/src/fr/escape/game/entity/weapons/shot/Shot.java
+++ b/src/fr/escape/game/entity/weapons/shot/Shot.java
@@ -9,5 +9,37 @@ import fr.escape.game.entity.Moveable;
 import fr.escape.game.message.Receiver;
 
 public interface Shot extends Drawable, Moveable, Receiver, Entity {
+	
+	/**
+	 * @see Shot#receive(int)
+	 */
+	public final static int MESSAGE_LOAD = 0;
+	public final static int MESSAGE_FIRE = 1;
+	public final static int MESSAGE_CRUISE = 2;
+	public final static int MESSAGE_HIT = 3;
+	public final static int MESSAGE_DESTROY = 4;
+	
+	/**
+	 * <p>
+	 * Shot have different state depending on the situation.
+	 * 
+	 * <p>
+	 * If you need to change its state, use this method with the given protocol:
+	 * 
+	 * <ul>
+	 * <li>MESSAGE_LOADED: Shot loaded in Ship.</li>
+	 * <li>MESSAGE_FIRE: Shot just shoot from Ship.</li>
+	 * <li>MESSAGE_CRUISE: Shot in cruise state.</li>
+	 * <li>MESSAGE_HIT: Shot hit something.</li>
+	 * <li>MESSAGE_DESTROY: Shot need to be destroyed.</li>
+	 * </ul>
+	 * 
+	 * <b>By default:</b> state is 0.
+	 * 
+	 * @see Receiver#receive(int)
+	 */
+	@Override
+	public void receive(int message);
+	
 	public void setPosition(World world,Graphics graphics,float[] velocity);
 }
diff --git a/src/fr/escape/game/screen/Splash.java b/src/fr/escape/game/screen/Splash.java
index 369d0ac..701a32b 100644
--- a/src/fr/escape/game/screen/Splash.java
+++ b/src/fr/escape/game/screen/Splash.java
@@ -159,20 +159,20 @@ public class Splash implements Screen {
 			}
 		}*/
 		
-		if((time % 1000) > 0 && (time % 1000) < 100) {
-			
-			if(!spawn) {
-				Bonus bonus = BonusFactory.createBonus(eContainer);
-				if(bonus != null) {
-					bonus.setPosition(game.getGraphics().getWidth() / 2, 0);
-					eContainer.push(bonus);
-				}
-				spawn = true;
-			}
-			
-		} else {
-			spawn = false;
-		}
+//		if((time % 1000) > 0 && (time % 1000) < 100) {
+//			
+//			if(!spawn) {
+//				Bonus bonus = BonusFactory.createBonus(eContainer);
+//				if(bonus != null) {
+//					bonus.setPosition(game.getGraphics().getWidth() / 2, 0);
+//					eContainer.push(bonus);
+//				}
+//				spawn = true;
+//			}
+//			
+//		} else {
+//			spawn = false;
+//		}
 		//world.step(1.0f/60.0f,6,2);
 	}
 
diff --git a/src/fr/escape/input/Drift.java b/src/fr/escape/input/Drift.java
index ee47e53..3b19ab8 100644
--- a/src/fr/escape/input/Drift.java
+++ b/src/fr/escape/input/Drift.java
@@ -7,33 +7,45 @@ import fr.escape.app.Input;
 //TODO Comment
 public final class Drift implements Gesture {
 
+	private static int DEFAULT_FAULT_TOLERANCE = 20;
+	private static double UP_COEFFICIENT = 0.3;
+	private static double DOWN_COEFFICIENT = 1.7;
+	
 	@Override
-	public boolean accept(Input start, List<Input> events,Input end,float[] velocity) {
-		if(start.getY() <= end.getY()) return false;
-		int faultTolerence = 20;
-		boolean isRight = start.getX() < end.getX();
+	public boolean accept(Input start, List<Input> events, Input end, float[] velocity) {
 		
-		double upCoeffDir, downCoeffDir;
-		if(isRight) {
-			upCoeffDir = -0.3;
-			downCoeffDir = -1.7;
-		} else {
-			upCoeffDir = 1.7;
-			downCoeffDir = 0.3;
+		if(start.getY() <= end.getY()) {
+			return false;
 		}
-  		double cd = (double)(end.getY()-start.getY())/(end.getX()-start.getX());
+		
+		double upCoeffDir;
+		double downCoeffDir;
+		int faultTolerance = DEFAULT_FAULT_TOLERANCE;
+		boolean isRight = start.getX() < end.getX();
+
+		upCoeffDir = (isRight)?(-UP_COEFFICIENT):(UP_COEFFICIENT);
+		downCoeffDir = (isRight)?(-DOWN_COEFFICIENT):(DOWN_COEFFICIENT);
+		
+  		double cd = (double) ((end.getY() - start.getY()) / (end.getX() - start.getX()));
 
   		if(downCoeffDir < cd && cd < upCoeffDir) {
-  			double pUp = (end.getY() + faultTolerence) - (cd * (end.getX() + faultTolerence));
-      		double pDown = (end.getY() - faultTolerence) - (cd * (end.getX() - faultTolerence));
+  			
+  			double pUp = (end.getY() + faultTolerance) - (cd * (end.getX() + faultTolerance));
+      		double pDown = (end.getY() - faultTolerance) - (cd * (end.getX() - faultTolerance));
+      		
       		for(Input event : events) {
-      			double yUp = cd * event.getX() + pUp;
-      			double yDown = cd * event.getX() + pDown;
-      			//System.out.println(yUp + " " + event.getY() + " " + yDown);
-      			if(yUp < event.getY() || yDown > event.getY()) return false;
+      			
+      			double yUp = (cd * event.getX()) + pUp;
+      			double yDown = (cd * event.getX()) + pDown;
+      			
+      			if(yUp < event.getY() || yDown > event.getY()) {
+      				return false;
+      			}
+      			
       		}
       		
       		velocity[2] = -0.5f;
+      		
       		if(isRight) {
       			velocity[0] = (end.getX() - start.getX()) / 10;
       			velocity[1] = 0.5f;
